// Generated by CoffeeScript 1.9.1

/*
the base Field class and most of the core fields.
 */

(function() {
  var BooleanField, CharField, ChoiceField, EmailField, Field, FloatField, IntegerField, NullBooleanField, RegexField, ValidationError, _, fields, utils, validators,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  if (typeof exports !== "undefined" && exports !== null) {
    utils = require("./utils");
    validators = require("./Validators");
    _ = require("underscore");
  } else if (typeof window !== "undefined" && window !== null) {
    utils = window.utils;
    validators = window.validators;
    _ = window._;
  }

  ValidationError = utils.ValidationError;

  Field = (function() {

    /*
    Baseclass for all fields. Fields are defined by a schema. 
    You can override attributes and methods within the schema. 
    For example:
    
        var simpleSchema = { name: "firstField"
                           , field: "Field"
                           , required: false
                           };
    
    will create a basic field that is not required.
    This is not particularly useful.
    But we can create useful fields using subclasses of Field:
    
        var pwSchema = { name: "badPasswordField"
                       , field: "CharField"
                       , maxLength: 8
                       , minLength: 4
                       , widget: "Widgets.PasswordWidget"
                       };
    
    Now we have created a very insecure password field schema.
    We have overridden the Charfield's default widget with a password widget.
    
    We create a Field instance from a schema by calling:
    
        simpleField = validoc.genField(simpleSchema);
    
    We create a ReactJS widget component from a schema by calling:
    
        simpleWidget = validoc.genWidget(simpleSchema);
    
    The following attributes can be specified in the schema.
    Any defaults can be overridden by subclasses:
      
      * `field`: the field type (e.g. CharField, ContainerField) (required)
      * `name`: the name/identifier for this field (required)
      * `widget`: widget constructor hash or string name
         (e.g. { widget: "widget.Widget"}, or simply "widget.Widget")
         (default: depends on Field type)
      * `required`: whether the current field is required (default: true)
      * `default`: the default value of the field.
        If the value is undefined, the value will be set to the default value.
    
    
    When you call genField or genWidget,
    you can specify `value` and `initialValue` as optional 2nd and 3rd 
    arguments, respectively.
    
      * `value`: the current value of the field
      * `initialValue`: the initial value of the field (useful for validation)
    
    The following attributes can also technically be specified in the schema,
    but in practice, the should only have to be modified by subclasses:
    
      * `errorMessages`: hash of error message codes and keys.
        You can override any error message by setting a new message for the code.
      * `validators`: array of validators;
        If overriding a parent class, you must include all ancestor validators
      * `listeners`: hash of listeners of one of the following forms:
        * `'event': (inSender, inEvent) ->`
        * `'event': "handlerMethod"`
        * `'*': "handlerMethod"`
        wildcard will handle all incoming events
    
    You are probably doing something wrong if you access an attribute
    that starts with an underscore. You should **never** directly modify
    any attribute that starts with an underscore.
     */
    Field.prototype.name = void 0;

    Field.prototype.required = true;

    Field.prototype.widget = "widgets.Widget";


    /*
    hash of listeners of the form
        * `'event': (inSender, inEvent) ->`
        * `'event': "handlerMethod"`
        * `'*': "handlerMethod"`
    wildcard will handle all incoming events
     */

    Field.prototype.listeners = {};

    Field.prototype.validators = [];

    Field.prototype.errorMessages = {
      required: utils._i('This field is required.')
    };

    Field.prototype._clean = void 0;

    Field.prototype._errors = [];

    Field.prototype._parent = void 0;

    Field.prototype.value = void 0;

    Field.prototype.initial = void 0;

    Field.prototype["default"] = void 0;

    function Field(opts) {
      var ref, schema;
      if (opts == null) {
        opts = {};
      }
      this.opts = _.clone(opts);
      this.errorMessages = this._walkProto("errorMessages");
      if (opts.errorMessages) {
        _.extend(this.errorMessages, opts.errorMessages);
        delete opts.errorMessages;
      }
      this.listeners = {};
      if (opts.value == null) {
        opts.value = opts.initial;
      }
      if (opts.initial == null) {
        opts.initial = opts.value;
      }
      _.extend(this, opts);
      delete this.value;
      if (((ref = this._parent) != null ? ref._fields : void 0) != null) {
        this._parent._fields.push(this);
      }
      this.validators = _.clone(this.validators);
      this.emit("onFieldAdd", {
        schema: this.opts,
        value: opts.value
      });
      if (this.setSchema) {
        schema = _.clone(this.schema);
        delete this.schema;
        this.setSchema(schema, {
          value: opts.value
        });
      }
      this.setValue(opts.value);
    }

    Field.prototype._walkProto = function(attr) {

      /* walks the prototype chain collecting all the values off attr and combining them in one. */
      var sup;
      sup = this.constructor.__super__;
      if (sup != null) {
        return _.extend(_.clone(sup._walkProto(attr)), this[attr]);
      } else {
        return this[attr];
      }
    };

    Field.prototype.getErrors = function() {

      /* get the errors for this field. returns null if no errors. */
      this.isValid();
      if (this._errors.length) {
        return this._errors;
      } else {
        return null;
      }
    };

    Field.prototype.toJavascript = function(value) {

      /*
      First function called in validation process.<br />
      this function converts the raw value to javascript. `value` is the raw value from
      `@getValue()`. The function returns the value in the proper javascript format,<br />
      this function should be able to convert from any type that a widget might supply to the type needed for validation
       */
      return value;
    };

    Field.prototype._valid = false;

    Field.prototype._hasChanged = true;

    Field.prototype.validate = function(value) {

      /*
      Second function called in validation process.<br />
      Any custom validation logic should be placed here. receives the input, `value`, from `toJavascript`'s output.
      return the value with any modifications. When validation fails, throw a utils.ValidationError. with a 
      default error message, a unique error code, and any attributes for string interpolation of the error message
      be sure to call `@super <br />
      default action is to check if the field is required
       */
      if (validators.isEmpty(value) && this.required) {
        throw ValidationError(this.errorMessages.required, "required");
      }
      return value;
    };

    Field.prototype.runValidators = function(value) {

      /*
      Third function called in validation process.<br />
      You should not have to override this function. simply add validators to @validators.
       */
      var i, len, ref, v;
      if (validators.isEmpty(value)) {
        return;
      }
      ref = this.validators;
      for (i = 0, len = ref.length; i < len; i++) {
        v = ref[i];
        this._catchErrors(v, value);
      }
      return value;
    };

    Field.prototype.isValid = function(opts) {

      /* primary validation function<br />
      calls all other validation subfunctions and emits a `validChanged` event if the valid state has changed.
      returns `true` or `false`
      only precesses the full validation if hasChanged is true, which is only true if something has changed since the last call to isValid()
      emits the `validChanged` event if the valid state has changed.
       */
      var oldErrors, valid, value;
      if (!this._hasChanged) {
        return this._valid;
      }
      oldErrors = _.clone(this._errors);
      this._errors = [];
      value = this.getValue();
      value = this._catchErrors(this.toJavascript, value);
      if (!this._errors.length) {
        value = this._catchErrors(this.validate, value);
      }
      if (!this._errors.length) {
        value = this.runValidators(value);
      }
      valid = !this._errors.length;
      this._clean = valid ? value : void 0;
      if (valid !== this._valid || !valid && !_.isEqual(oldErrors, this._errors)) {
        this.emit("onValidChanged", {
          valid: valid,
          errors: this._errors
        });
        this._valid = valid;
      }
      this._hasChanged = false;
      return valid;
    };

    Field.prototype._catchErrors = function(fn, value) {

      /* helper function for running an arbitrary function, capturing errors and placing in error array */
      var e, message;
      try {
        if (fn instanceof Function) {
          value = fn.call(this, value);
        } else {
          value = fn.validate(value);
        }
      } catch (_error) {
        e = _error;
        message = this.errorMessages[e.code] != null ? this.errorMessages[e.code] : e.message;
        if (e.params != null) {
          message = utils.interpolate(message, e.params);
        }
        this._errors.push(message);
      }
      return value;
    };

    Field.prototype.getClean = function(opts) {

      /*
      return the fild's cleaned data if there are no errors. throws an error if there are validation errors.
      you will likely have to override this in Field subclasses
       */
      var valid;
      valid = this.isValid(opts);
      if (!valid) {
        throw this._errors;
      }
      return this._clean;
    };

    Field.prototype.toJSON = function(opts) {

      /*
      return the field's cleaned data in serializable form if there are no errors. throws an error if there are validation errors.  
      you might have to override this in Field subclasses.
       */
      return this.getClean(opts);
    };

    Field.prototype.setRequired = function(val) {
      if (val !== this.required) {
        this._hasChanged = true;
        this.required = val;
        return this.emit("onRequiredChanged", {
          required: this.required
        });
      }
    };

    Field.prototype.setValue = function(val, opts) {

      /* You should not have to override this in Field subclasses */
      var origValue;
      if (val === void 0) {
        val = this["default"];
      }
      if (val !== this.value) {
        this._hasChanged = true;
        origValue = this.value;
        this.value = val;
        return this.emit("onValueChanged", {
          value: this.getValue(),
          original: origValue
        });
      }
    };

    Field.prototype.getValue = function() {

      /* You should not have to override this in Field subclasses */
      return this.value;
    };

    Field.prototype.getPath = function() {

      /*
      Get an array of the unique path to the field. A ListField's subfields are denoted by an integer representing the index of the subfield.
      A ContainerField's subfields are denoted by a string or integer representing the key of the subfield.
      Example:
      {parent: {child1: hello, child2: [the, quick, brown, fox]}}
      ["parent", "child2", 1] points to "quick"
      [] points to {parent: {child1: hello, child2: [the, quick, brown, fox]}}
       */
      if (this._parent) {
        return this._parent.getPath(this);
      } else {
        return [];
      }
    };

    Field.prototype.getField = function(path) {

      /* get a field given a path */
      if (path.length > 0) {
        return void 0;
      } else {
        return this;
      }
    };

    Field.prototype.emit = function(eventName, inEvent) {

      /*
      emit an event that bubbles up the field tree.
      
      * `eventName`: name of the event to emit
      * `inEvent`: optional hash of data to send with the event
       */
      if (inEvent == null) {
        inEvent = {};
      }
      inEvent.originator = this;
      return this._bubble(eventName, null, inEvent);
    };

    Field.prototype._bubble = function(eventName, inSender, inEvent) {

      /* handle bubbling to parent */
      var i, len, listener, ref;
      ref = this._getProtoListeners(eventName, true);
      for (i = 0, len = ref.length; i < len; i++) {
        listener = ref[i];
        if (listener.apply(this, [inSender, inEvent]) === true) {
          return;
        }
      }
      if (this._parent) {
        return this._parent._bubble(eventName, this, inEvent);
      }
    };

    Field.prototype._getProtoListeners = function(eventName, start) {

      /* handle bubbling up the prototype chain */
      var listener, sup;
      sup = start ? this.constructor.prototype : this.constructor.__super__;
      listener = this.listeners[eventName] || this.listeners["*"];
      listener = listener instanceof Function ? listener : this[listener];
      listener = listener != null ? [listener] : [];
      if (sup != null) {
        return sup._getProtoListeners(eventName).concat(listener);
      } else {
        return listener;
      }
    };

    return Field;

  })();

  CharField = (function(superClass) {
    extend(CharField, superClass);


    /*
    a field that contains a string.  
    Attributes:
    
     * `maxLength`: The maximum length of the string (optional)
     * `minLength`: The minimum length of the string (optional)
    
    Default widget: Widget
     */

    CharField.prototype.maxLength = void 0;


    /* The minimum length of the string (optional) */

    CharField.prototype.minLength = void 0;

    function CharField(opts) {
      CharField.__super__.constructor.call(this, opts);
      if (this.maxLength != null) {
        this.validators.push(new validators.MaxLengthValidator(this.maxLength));
      }
      if (this.minLength != null) {
        this.validators.push(new validators.MinLengthValidator(this.minLength));
      }
    }

    CharField.prototype.toJavascript = function(value) {
      value = validators.isEmpty(value) ? "" : value;
      return value;
    };

    return CharField;

  })(Field);

  IntegerField = (function(superClass) {
    extend(IntegerField, superClass);


    /*
    a field that contains a whole number.  
    Attributes:  
    
     * `maxValue`: Maximum value of integer
     * `minValue`: Minimum value of integer
    
    Default widget: Widget
     */

    IntegerField.prototype.maxValue = void 0;

    IntegerField.prototype.minValue = void 0;

    IntegerField.prototype.errorMessages = {
      invalid: utils._i('Enter a whole number.')
    };

    function IntegerField(opts) {
      IntegerField.__super__.constructor.call(this, opts);
      if (this.maxValue != null) {
        this.validators.push(new validators.MaxValueValidator(this.maxValue));
      }
      if (this.minValue != null) {
        this.validators.push(new validators.MinValueValidator(this.minValue));
      }
    }

    IntegerField.prototype.parseFn = parseInt;

    IntegerField.prototype.regex = /^-?\d*$/;

    IntegerField.prototype.toJavascript = function(value) {
      if (typeof value === "string" && !value.match(this.regex)) {
        throw ValidationError(this.errorMessages.invalid, "invalid");
      }
      value = validators.isEmpty(value) ? void 0 : this.parseFn(value, 10);
      if ((value != null) && isNaN(value)) {
        throw ValidationError(this.errorMessages.invalid, "invalid");
      }
      return value;
    };

    return IntegerField;

  })(Field);

  FloatField = (function(superClass) {
    extend(FloatField, superClass);


    /*
    A field that contains a floating point number.  
    Attributes:
    
      * `maxDecimals`: Maximum number of digits after the decimal point
      * `minDecimals`: Minimum number of digits after the decimal point
      * `maxDigits`: Maximum number of total digits before and after the decimal point
    
    Default widget: Widget
     */

    FloatField.prototype.maxDecimals = void 0;

    FloatField.prototype.minDecimals = void 0;

    FloatField.prototype.maxDigits = void 0;

    FloatField.prototype.errorMessages = {
      invalid: utils._i('Enter a number.')
    };

    function FloatField(opts) {
      FloatField.__super__.constructor.call(this, opts);
      if (this.maxDecimals != null) {
        this.validators.push(new validators.MaxDecimalPlacesValidator(this.maxDecimals));
      }
      if (this.minDecimals != null) {
        this.validators.push(new validators.MinDecimalPlacesValidator(this.minDecimals));
      }
      if (this.maxDigits != null) {
        this.validators.push(new validators.MaxDigitsValidator(this.maxDigits));
      }
    }

    FloatField.prototype.parseFn = parseFloat;

    FloatField.prototype.regex = /^\d*\.?\d*$/;

    return FloatField;

  })(IntegerField);

  RegexField = (function(superClass) {
    extend(RegexField, superClass);


    /*
    A baseclass for subclassing.
    Attributes:
    
      * `regex`: the compiled regex to test against
      * `errorMessage`: the error message to display when the regex fails
    
    Default widget: Widget
     */

    RegexField.prototype.regex = void 0;

    RegexField.prototype.errorMessage = void 0;

    function RegexField(opts) {
      RegexField.__super__.constructor.call(this, opts);
      this.validators.push(new validators.RegexValidator(this.regex));
      if (this.errorMessage) {
        this.errorMessages.invalid = this.errorMessage;
      }
    }

    return RegexField;

  })(Field);

  EmailField = (function(superClass) {
    extend(EmailField, superClass);

    function EmailField() {
      return EmailField.__super__.constructor.apply(this, arguments);
    }


    /*
    A field that contains a valid email.  
    Attributes:
    
      * None
    
    Default widget: EmailWidget
     */

    EmailField.prototype.widget = "widgets.EmailWidget";

    EmailField.prototype.validators = [new validators.EmailValidator()];

    return EmailField;

  })(RegexField);

  BooleanField = (function(superClass) {
    extend(BooleanField, superClass);

    function BooleanField() {
      return BooleanField.__super__.constructor.apply(this, arguments);
    }


    /*
    A field that contains a Boolean value. Must be true or false.
    if you want to be able to store null us `NullBooleanField`
    Attributes:
    
      * none
    
    Default widget: CheckboxWidget
     */

    BooleanField.prototype.widget = "widgets.CheckboxWidget";

    BooleanField.prototype.toJavascript = function(value) {
      var ref;
      if (typeof value === "string" && ((ref = value.toLowerCase()) === "false" || ref === "0")) {
        value = false;
      } else {
        value = Boolean(value);
      }
      if (!value && this.required) {
        throw ValidationError(this.errorMessages.required, "required");
      }
      return value;
    };

    return BooleanField;

  })(Field);

  NullBooleanField = (function(superClass) {
    extend(NullBooleanField, superClass);

    function NullBooleanField() {
      return NullBooleanField.__super__.constructor.apply(this, arguments);
    }


    /*
    A field that contains a Boolean value. The value can be 
    true, false, or null.  
    Attributes:
    
      * none
    
    Default widget: CheckboxWidget
     */

    NullBooleanField.prototype.toJavascript = function(value) {
      if (value === true || value === "True" || value === "1") {
        value = true;
      } else if (value === false || value === "False" || value === "0") {
        value = false;
      } else {
        value = null;
      }
      return value;
    };

    NullBooleanField.prototype.validate = function(value) {
      return value;
    };

    return NullBooleanField;

  })(BooleanField);

  ChoiceField = (function(superClass) {
    extend(ChoiceField, superClass);


    /*
    A field that contains value from a list of values.  
    Attributes:
    
      * `choices`: Array of 2-arrays specifying valid choices. if 2-arrays, first value is value, second is display. create optgroups by setting display If display value to a 2-array. MUST USE `setChoices`.
    
    Default widget: ChoiceWidget
     */

    ChoiceField.prototype.widget = "widgets.ChoiceWidget";

    ChoiceField.prototype.choices = [];

    ChoiceField.prototype.errorMessages = {
      invalidChoice: utils._i('Select a valid choice. %(value)s is not one of the available choices.')
    };

    function ChoiceField(opts) {
      if (opts.choices) {
        this.choices = opts.choices;
      }
      this.setChoices(_.clone(this.choices));
      ChoiceField.__super__.constructor.call(this, opts);
    }

    ChoiceField.prototype.setChoices = function(val) {
      var choices, iterChoices;
      choices = {};
      iterChoices = function(x) {
        if (x[1] instanceof Array) {
          return _.forEach(x[1], iterChoices);
        } else {
          return choices[x[0]] = x[1];
        }
      };
      _.forEach(this.choices, iterChoices);
      return this.choicesIndex = choices;
    };

    ChoiceField.prototype.toJavascript = function(value) {
      value = validators.isEmpty(value) ? "" : value;
      return value;
    };

    ChoiceField.prototype.validate = function(value) {
      value = ChoiceField.__super__.validate.call(this, value);
      if (value && !this.validValue(value)) {
        throw ValidationError(this.errorMessages.invalidChoice, "invalidChoice", value);
      }
      return value;
    };

    ChoiceField.prototype.validValue = function(val) {
      return val in this.choicesIndex;
    };

    ChoiceField.prototype.getDisplay = function() {
      return this.choices[this.getClean()];
    };

    return ChoiceField;

  })(Field);

  fields = {
    Field: Field,
    CharField: CharField,
    IntegerField: IntegerField,
    FloatField: FloatField,
    RegexField: RegexField,
    EmailField: EmailField,
    BooleanField: BooleanField,
    NullBooleanField: NullBooleanField,
    ChoiceField: ChoiceField,
    getField: function(path) {
      var i, len, out, part;
      path = path.split(".");
      out = this;
      for (i = 0, len = path.length; i < len; i++) {
        part = path[i];
        out = out[part];
      }
      return out;
    },
    genField: function(schema, parent, value) {
      var field;
      schema = _.clone(schema);
      schema._parent = parent;
      if (value != null) {
        schema.value = value;
      }
      field = this.getField(schema.field);
      if (!field) {
        throw Error("Unknown field: " + schema.field);
      }
      return new field(schema);
    }
  };

  if (typeof window !== "undefined" && window !== null) {
    window.fields = fields;
  } else if (typeof exports !== "undefined" && exports !== null) {
    require("./ContainerFields")(fields);
    module.exports = fields;
  }

}).call(this);
